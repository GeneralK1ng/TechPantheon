今天继续复习数据库，顺序就按照学校的来，我也不知道从哪里开始讲。

# 什么是SQL？

`SQL`的全称是 **“Structured Query Language”**，也就是结构化查询语言，是一种用于访问和处理数据库的标准的计算机语言。

## SQL可以干什么？

`SQL`主要分为两种，一种是`DDL`（**Data Definition Language**），另一种是`DML`（**Data Manipulation Language**）。

**DDL（数据定义语言）：**

- **解释：** DDL 是用于定义和管理数据库结构的语言。
- **比喻：** 想象数据库是一个房子，DDL 就像是建造房子的工具和规划图。它负责定义房子的基本结构，比如房间的数量、形状，以及窗户、门等的位置。
- **例子：** 如果你想在数据库中创建一个新的表格来存储学生信息，你会使用DDL 来定义这个表格的结构，包括每个字段的类型和大小。

```sql
CREATE TABLE 学生表 (
    姓名 VARCHAR(50),
    年龄 INT,
    成绩 FLOAT
);
```

**DML（数据操作语言）：**

- **解释：** DML 是用于操作（添加、修改、删除）数据库中实际数据的语言。
- **比喻：** 如果 DDL 是用来规划和建造房子的工具，那么 DML 就是用来在房子里进行装修和整理的工具。
- **例子：** 如果你想在学生表中添加一条新的学生记录，你会使用 DML。

```sql
INSERT INTO 学生表 (姓名, 年龄, 成绩) VALUES ('小明', 15, 95);
```

## 建立表格

当你使用MySQL建表时，可以把表想象成一个电子表格，每个表格有一些列（字段），每列代表一种数据类型，而每一行则代表一条记录。

这就是一般建表的语法：

```sql
CREATE TABLE 表名 (
    列1 数据类型,
    列2 数据类型,
    列3 数据类型,
    ...
);
```

现在，我们可以通过一个具体的例子来说明。假设我们要创建一个存储学生信息的表，包括学生ID、姓名、年龄和成绩。我们可以这样写：

```sql
CREATE TABLE 学生表 (
    学生ID INT,
    姓名 VARCHAR(50),
    年龄 INT,
    成绩 FLOAT
);
```

在这个例子中，我们创建了一个名为“学生表”的表，其中包含了四个列：学生ID（整数类型）、姓名（最大长度为50的字符串类型）、年龄（整数类型）和成绩（浮点数类型）。

1. **表名：** 就像给一个文件起名一样，我们给我们的表起了一个名字，这个表的名字叫做“学生表”。
2. **列名和数据类型：** 就像填写一个表格一样，我们定义了表格的每一列。例如，学生表中有学生ID、姓名、年龄和成绩这四列。而每一列都有对应的数据类型，比如学生ID是整数类型，姓名是字符串类型，年龄也是整数类型，成绩是浮点数类型。

### 命名对象注意规范

在MySQL中，命名对象（例如表名、列名、数据库名等）时，你会经常看到使用引号（单引号或双引号）或反引号（\`）来括住这些名称。它们的使用有一些区别：

1. **单引号和双引号：**
   - 单引号（\'）和双引号（\"）在MySQL中通常用于表示字符串值。例如，`SELECT * FROM 表 WHERE 列 = '某个值';`。
   - 但是，当命名数据库对象（如表名、列名）时，单引号和双引号并不是标准的用法，而通常使用反引号。
2. **反引号（`）：**
   - 在MySQL中，反引号主要用于标识数据库对象的名称，如表名、列名等。它是MySQL中用于引用标识符（identifiers）的一种方式。
   - 使用反引号可以确保MySQL正确解释标识符，即使标识符中包含了MySQL关键字或特殊字符。
   - 举例说明，在使用反引号的情况下，你可以创建一个包含空格的列名：CREATE TABLE 表名 (\`有空格的列\` INT);

举例来说明：

```sql
-- 使用反引号命名表名和列名
CREATE TABLE `学生表` (
    `学生ID` INT,
    `姓名` VARCHAR(50),
    `年龄` INT,
    `成绩` FLOAT
);

-- 查询数据时也要使用反引号
SELECT `学生ID`, `姓名` FROM `学生表` WHERE `年龄` > 18;
```

# MySQL中的数据类型

## **整数类型：**

- **TINYINT:**
  - 范围：-128 到 127 （有符号），0 到 255 （无符号）
  - 存储空间：1字节
- **SMALLINT:**
  - 范围：-32,768 到 32,767 （有符号），0 到 65,535 （无符号）
  - 存储空间：2字节
- **MEDIUMINT:**
  - 范围：-8,388,608 到 8,388,607 （有符号），0 到 16,777,215 （无符号）
  - 存储空间：3字节
- **INT (INTEGER):**
  - 范围：-2,147,483,648 到 2,147,483,647 （有符号），0 到 4,294,967,295 （无符号）
  - 存储空间：4字节
- **BIGINT:**
  - 范围：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 （有符号），0 到 18,446,744,073,709,551,615 （无符号）
  - 存储空间：8字节

**注意事项：**

- 在上述范围内，有符号整数类型的范围是从负数到正数，而无符号整数类型的范围是从0到正数。
- 要注意的是，选择整数类型时，应根据存储需求选择合适的类型，以避免浪费存储空间。如果知道数据永远不会为负，可以考虑使用无符号整数类型，这将扩大可表示的正数范围。

## **浮点数和定点数类型：**

**1. 浮点数类型:**

- `FLOAT`和`DOUBLE`是MySQL中用于存储浮点数的数据类型。
- `FLOAT`存储单精度浮点数，占用4字节。
- `DOUBLE`存储双精度浮点数，占用8字节。

**注意事项：**

- 浮点数在表示小数时可能存在精度问题，因为它们是以二进制形式存储的。
- 在科学计算等需要广范围和较高精度的场景中使用。

**例子：**

```sql
CREATE TABLE 浮点数表 (
    列1 FLOAT,
    列2 DOUBLE
);
```

**2. 定点数类型:**

- `DECIMAL`是MySQL中用于存储定点数的数据类型，也称为精确数值类型。
- `DECIMAL`用于确保小数的精确性，而不会受到浮点数精度问题的影响。
- `DECIMAL`存储的小数点位数是固定的，通过指定精度和小数位数来定义。

**注意事项：**

- 适用于需要高精度计算，如货币或其他需要精确小数位的场景。
- 占用的存储空间和定义的精度和小数位数相关。

**例子：**

```sql
CREATE TABLE 定点数表 (
    列1 DECIMAL(10, 2),
    列2 DECIMAL(8, 4)
);
```

在这个例子中，`DECIMAL(10, 2)`表示总共10位数，其中包括2位小数；而`DECIMAL(8, 4)`表示总共8位数，其中包括4位小数。

总体而言，选择浮点数还是定点数取决于应用的需求。如果需要高精度，特别是在与货币相关的场景中，建议使用`DECIMAL`。如果对精度要求相对较低，而且需要处理大量数据，可以考虑使用`FLOAT`或`DOUBLE`。

## **字符串类型：**

在MySQL中，有几种常见的字符串类型，包括`CHAR`、`VARCHAR`、`TEXT`。这些类型之间有一些关键的区别，主要涉及存储方式、长度限制和性能等方面。

**CHAR:**

- `CHAR`是一种固定长度的字符串类型，即使存储的字符串长度不足，也会占用指定长度的空间。
- 例如，如果定义了一个`CHAR(10)`，那么不管实际存储的字符串是"abc"还是"abcdefghij"，都会占用10个字符的存储空间。

**注意事项：**

- 适用于存储长度固定的字符串，比如存储国家代码或其他长度一致的数据。
- 如果存储的字符串长度变化较大，可能会浪费存储空间。

**例子：**

```sql
CREATE TABLE 字符表 (
    列1 CHAR(10),
    列2 CHAR(50)
);
```

**VARCHAR:**

- `VARCHAR`是一种可变长度的字符串类型，它只占用存储的实际数据长度加上一些额外的字节。
- 例如，如果定义了一个`VARCHAR(10)`，实际存储的字符串是"abc"，那么只会占用4个字符的存储空间（3个字符的数据加上一个用于存储长度的字节）。

**注意事项：**

- 适用于存储长度变化较大的字符串，可以节省存储空间。
- `VARCHAR`最大长度受数据库引擎的限制。

**例子：**

```sql
CREATE TABLE 可变字符表 (
    列1 VARCHAR(10),
    列2 VARCHAR(50)
);
```

**TEXT:**

- `TEXT`用于存储大文本数据，可以存储较长的字符串。
- 与`VARCHAR`不同，`TEXT`没有指定长度，可以存储非常大的文本数据。

**注意事项：**

- 适用于存储非常长的文本数据，如文章内容、日志等。
- `TEXT`类型的数据在排序和索引上的性能可能不如`CHAR`和`VARCHAR`。

**例子：**

```sql
CREATE TABLE 文本表 (
    列1 TEXT,
    列2 LONGTEXT
);
```

总体而言，选择哪种字符串类型取决于实际的数据需求。如果字符串长度是固定的，使用`CHAR`可能更为合适。如果长度变化较大，但不会超过某个限定值，使用`VARCHAR`。如果需要存储非常长的文本数据，使用`TEXT`。

## **日期和时间类型：**

**DATE:**

- `DATE`用于存储日期，不包含时间部分。
- 格式为'YYYY-MM-DD'。

**注意事项：**

- 适用于存储不需要精确到时分秒的日期信息。

**TIME:**

- `TIME`用于存储时间，不包含日期部分。
- 格式为'HH:MM:SS'。

**注意事项：**

- 适用于存储不需要日期信息的时间。

**DATETIME:**

- `DATETIME`用于存储日期和时间。
- 格式为'YYYY-MM-DD HH:MM:SS'。

**注意事项：**

- 适用于需要同时存储日期和时间的情况。

**TIMESTAMP:**

- `TIMESTAMP`也用于存储日期和时间。
- 格式为'YYYY-MM-DD HH:MM:SS'。
- `TIMESTAMP`还具有特殊的自动更新功能，即当记录插入或更新时，`TIMESTAMP`列会自动更新为当前时间戳。

**注意事项：**

- 适用于需要记录时间戳并且可能需要自动更新的情况。

总的来说，选择日期和时间类型取决于存储需求。如果只需要日期或时间，可以选择`DATE`或`TIME`。如果需要同时存储日期和时间，可以选择`DATETIME`或`TIMESTAMP`。在选择时还需要考虑是否需要自动更新功能。

## **枚举和集合类型：**

在MySQL中，枚举（ENUM）和集合（SET）是用于存储一组离散值的数据类型。它们允许你定义一组可能的值，然后将某一列的值限制在这个集合内。以下是它们的详细解释：

**ENUM:**

- `ENUM`用于存储一组预定义的可能取值。
- 你可以在定义列的时候列举出所有可能的取值，然后在数据表中存储这些取值中的一个。
- 例如，`ENUM('男', '女')`表示这个列的值只能是'男'或'女'中的一个。

**注意事项：**

- `ENUM`适用于有限且固定的取值集合。
- 存储的值是按照定义时的顺序来排序的。

**例子：**

```sql
CREATE TABLE 枚举表 (
    列1 ENUM('小', '中', '大')
);
```

**SET:**

- `SET`也用于存储一组预定义的可能取值，但不同于`ENUM`，`SET`允许存储多个值，这些值是由逗号分隔的。
- 例如，`SET('篮球', '足球', '乒乓球')`表示这个列的值可以是单个选项，也可以是多个选项的组合，如'篮球'、'足球'、'篮球,乒乓球'等。

**注意事项：**

- `SET`适用于有限的且可以组合的取值集合。
- 存储的值是按照插入时的顺序来排序的。

**例子：**

```sql
CREATE TABLE 集合表 (
    列1 SET('苹果', '橙子', '香蕉')
);
```

这玩意可不常用，起码目前我还没用过。

## **二进制类型：**

在MySQL中，二进制类型用于存储二进制数据，例如图像、音频、视频等二进制文件。以下是MySQL中常见的二进制类型：

**BINARY 和 VARBINARY:**

- `BINARY`和`VARBINARY`用于存储二进制数据，其中`BINARY`是定长的，而`VARBINARY`是变长的。
- 例如，`BINARY(10)`表示存储长度为10的二进制数据，而`VARBINARY(255)`表示可以存储最大长度为255的变长二进制数据。

**注意事项：**

- 适用于存储固定或变长的二进制数据。

**例子：**

```sql
CREATE TABLE 二进制表 (
    列1 BINARY(10),
    列2 VARBINARY(255)
);
```

**BLOB:**

- `BLOB`是用于存储大型二进制对象的类型，适用于存储比较大的二进制数据。
- MySQL提供了不同大小的`BLOB`类型，包括`TINYBLOB`、`BLOB`、`MEDIUMBLOB`和`LONGBLOB`。

**注意事项：**

- 适用于存储大型的二进制数据，如图像、音频、视频等。
- `BLOB`类型的数据在排序和索引上的性能可能不如其他类型。

**例子：**

```sql
CREATE TABLE 二进制大对象表 (
    列1 BLOB,
    列2 LONGBLOB
);
```

这玩意更加不常用，一般我们会使用第三方提供的OSS（对象存储服务），便宜安全好用，还快，谁会往自家服务本地存东西？

## **空间数据类型：**

在MySQL中，空间数据类型用于存储与空间（地理或几何）相关的数据。以下是几种常见的空间数据类型：

1. **GEOMETRY:**

   - `GEOMETRY`类型用于存储任意几何对象。
   - 这包括点、线、多边形等各种几何形状。

   **注意事项：**

   - 适用于存储任意几何对象，但不能进行特定类型的分析或查询。

2. **POINT:**

   - `POINT`类型用于存储二维平面上的点。
   - POINT类型可以用来表示地理坐标，如经纬度。

   **注意事项：**

   - 适用于存储地理坐标等点的信息。

3. **LINESTRING:**

   - `LINESTRING`类型用于存储线。
   - 可以用一系列的点来定义一条线。

   **注意事项：**

   - 适用于存储线的几何信息。

4. **POLYGON:**

   - `POLYGON`类型用于存储多边形。
   - 可以用一系列的点来定义一个封闭的区域。

   **注意事项：**

   - 适用于存储多边形的几何信息。

这个我也没用过。。。。

> 存储空间的单位通常有字节（Byte）、千字节（KB）、兆字节（MB）、吉字节（GB）、太字节（TB）等。它们之间的换算关系如下：
>
> 1. **字节（Byte）:**
>    - 1 Byte = 8 比特（bit）
> 2. **千字节（KB）:**
>    - 1 KB = 1024 Bytes
> 3. **兆字节（MB）:**
>    - 1 MB = 1024 KB = 1024 * 1024 Bytes
> 4. **吉字节（GB）:**
>    - 1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Bytes
> 5. **太字节（TB）:**
>    - 1 TB = 1024 GB = 1024 * 1024 MB = 1024 * 1024 * 1024 KB = 1024 * 1024 * 1024 * 1024 Bytes
>
> 自个慢慢换算，感觉考试肯定有一道题考这个。

# 列选项（约束）

在MySQL中，当你创建表时，你可以为每个列指定一些选项，这些选项称为列选项（Column Options）。这些选项允许你进一步定制列的行为和特性。以下是一些常见的列选项：

## **NOT NULL**

使用`NOT NULL`选项是为了确保某一列的值不能为空（即不允许为NULL）。这对于确保数据的完整性和有效性是非常重要的。以下是关于`NOT NULL`选项的一些注意事项：

**数据完整性：**

- 主要目的是确保表中的每一行都有该列的值，从而维护数据的完整性。如果某一列没有`NOT NULL`选项，那么在插入数据时，该列可以为空。

**默认值：**

- 如果没有为列指定`DEFAULT`选项，而且该列被设置为`NOT NULL`，则在插入新行时必须为该列提供一个非NULL的值，否则插入将失败。

```sql
CREATE TABLE 表名 (
    列1 INT NOT NULL DEFAULT 0,
    列2 VARCHAR(50) NOT NULL DEFAULT '未知'
);
```

**索引和性能：**

- `NOT NULL`列上的索引通常比允许NULL值的列上的索引更有效。这是因为索引不需要考虑NULL值，因此在使用`NOT NULL`的列进行检索时可能更快。

**外键约束：**

- 如果某列被用作外键，通常会希望该列是`NOT NULL`的，以确保引用的完整性。外键通常引用主键，而主键列通常是`NOT NULL`的。

```sql
CREATE TABLE 父表 (
    列1 INT PRIMARY KEY
);

CREATE TABLE 子表 (
    列2 INT REFERENCES 父表(列1) NOT NULL
);
```

**查询条件：**

- 在查询数据时，`NOT NULL`条件可以用于过滤掉空值。例如，`SELECT * FROM 表名 WHERE 列1 IS NOT NULL;`

## **DEFAULT**

在MySQL中，`DEFAULT`选项用于指定列的默认值。如果在插入数据时未提供值，列将采用默认值。以下是关于`DEFAULT`选项的一些注意事项：

**默认值的类型：**

- 默认值必须是与列数据类型兼容的值。例如，如果列是整数类型，那么默认值必须是整数。如果类型不匹配，MySQL可能会尝试进行自动转换，但这可能导致错误或意外行为。

```sql
CREATE TABLE 表名 (
    列1 INT DEFAULT 0,
    列2 VARCHAR(50) DEFAULT '未知'
);
```

**NULL与DEFAULT的区别：**

- `DEFAULT`和`NULL`是不同的概念。如果列被定义为`NOT NULL`，并且没有指定`DEFAULT`值，那么插入数据时必须提供一个非NULL的值。如果列具有`DEFAULT`值，那么在插入数据时可以省略该列，而MySQL将使用默认值。

```sql
CREATE TABLE 表名 (
    列1 INT NOT NULL,
    列2 VARCHAR(50) DEFAULT '未知'
);
```

**多列的默认值：**

- 对于包含多个列的表，可以为每列分别指定默认值。这些默认值将在插入数据时使用。

```sql
CREATE TABLE 表名 (
    列1 INT DEFAULT 0,
    列2 VARCHAR(50) DEFAULT '未知',
    列3 DATE DEFAULT CURRENT_DATE
);
```

**系统函数和表达式：**

- 可以使用系统函数或表达式作为默认值，例如`CURRENT_DATE`表示当前日期，`NOW()`表示当前日期和时间。这使得可以动态地生成默认值。

```sql
CREATE TABLE 表名 (
    列1 INT DEFAULT 0,
    列2 VARCHAR(50) DEFAULT '未知',
    列3 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**注意默认值的影响：**

- 当在插入数据时未提供指定列的值时，MySQL将使用默认值。这可以确保即使没有显式提供值，表中的每一行都具有某些默认的初始值。

## **AUTO_INCREMENT**

`AUTO_INCREMENT`是MySQL中用于创建自增长列的选项。当插入一行数据时，自增长列会自动递增，为每一行分配一个唯一的标识。以下是关于`AUTO_INCREMENT`选项的一些注意事项：

**仅适用于整数类型：**

- `AUTO_INCREMENT`通常用于整数列，例如`INT`、`BIGINT`等。自增长列的值会从一个指定的起始值开始，然后按照指定的步长递增。

```sql
CREATE TABLE 表名 (
    列1 INT AUTO_INCREMENT,
    列2 VARCHAR(50),
    PRIMARY KEY (列1)
);
```

**唯一性：**

- 自增长列通常用作主键，确保每行的唯一性。由于每行的自增长值都不同，可以方便地用作唯一标识。

```sql
CREATE TABLE 表名 (
    列1 INT AUTO_INCREMENT PRIMARY KEY,
    列2 VARCHAR(50)
);
```

**指定起始值：**

- 可以使用`AUTO_INCREMENT`选项指定自增长列的起始值。这可以通过在创建表时使用`AUTO_INCREMENT = value`语法来完成。

```sql
CREATE TABLE 表名 (
    列1 INT AUTO_INCREMENT PRIMARY KEY,
    列2 VARCHAR(50)
) AUTO_INCREMENT = 100;
```

**不跳号：**

- 自增长列保证不会跳过任何值。即使删除了表中的某些行，下一行插入时仍会使用之前未使用的最小的自增长值。

**事务和并发：**

- 自增长列在事务和并发环境下的行为是可控的。不同的数据库引擎可能有不同的实现方式，但通常会保证生成唯一的自增长值。

**不适用于复制表：**

- 在使用复制表结构的操作（如`CREATE TABLE ... AS SELECT ...`）时，不会保留`AUTO_INCREMENT`属性。需要额外的步骤来设置新表的自增长属性。

**不可手动插入值：**

- 通常情况下，不建议手动插入值到自增长列。MySQL会自动为该列分配一个唯一的值。如果插入时指定了自增长列的值，系统可能会忽略该值并使用自己的自增长值。

## **PRIMARY KEY**

`PRIMARY KEY`用于定义表中的主键，主键是用来唯一标识表中每一行的一列或一组列。以下是关于`PRIMARY KEY`的一些注意事项：

**唯一性：**

- 主键必须保证唯一性，每一行都必须有不同的主键值。这确保了表中的每个记录都可以通过主键唯一标识。

```sql
CREATE TABLE 表名 (
    列1 INT PRIMARY KEY,
    列2 VARCHAR(50)
);
```

**不允许NULL：**

- 主键列不允许包含NULL值。每个主键列都必须包含一个非NULL的值。

```sql
CREATE TABLE 表名 (
    列1 INT PRIMARY KEY,
    列2 VARCHAR(50) NOT NULL
);
```

**唯一索引：**

- 主键在数据库中通常被实现为唯一索引。因此，通过主键进行查询或检索的速度很快。

**复合主键：**

- 主键可以包含多列，这称为复合主键。复合主键的组合值必须是唯一的。

```sql
CREATE TABLE 表名 (
    列1 INT,
    列2 INT,
    PRIMARY KEY (列1, 列2)
);
```

**自动递增：**

- 主键列通常与`AUTO_INCREMENT`一起使用，确保每次插入新记录时都生成唯一的主键值。

```sql
CREATE TABLE 表名 (
    列1 INT AUTO_INCREMENT PRIMARY KEY,
    列2 VARCHAR(50)
);
```

**外键关系：**

- 主键通常用作与其他表的外键关系。外键可以引用另一表中的主键，以确保数据的引用完整性。

```sql
CREATE TABLE 父表 (
    列1 INT PRIMARY KEY
);

CREATE TABLE 子表 (
    列2 INT,
    FOREIGN KEY (列2) REFERENCES 父表(列1)
);
```

**变更注意事项：**

- 在表已经存在的情况下，要添加主键，表中的数据必须保证唯一性。如果表中已经有重复的值，需要先处理这些冲突再添加主键。

```sql
ALTER TABLE 表名 ADD PRIMARY KEY (列1);
```

## **UNIQUE**

`UNIQUE`是用于定义唯一约束的关键字，在MySQL中，它用于确保表中的某一列或一组列的值是唯一的。以下是关于`UNIQUE`的一些注意事项：

**唯一性：**

- `UNIQUE`约束确保被约束的列中的所有值都是唯一的，不允许重复。

```sql
CREATE TABLE 表名 (
    列1 INT UNIQUE,
    列2 VARCHAR(50)
);
```

**NULL值：**

- 对于带有`UNIQUE`约束的列，NULL值在唯一性方面是例外的。即使有多个NULL值，它们在唯一性检查中不会相互冲突。

```sql
CREATE TABLE 表名 (
    列1 INT UNIQUE,
    列2 VARCHAR(50) UNIQUE
);
```

**复合唯一性：**

- `UNIQUE`约束可以应用于单列，也可以应用于多列，称为复合唯一性。复合唯一性要求所有列的组合值是唯一的。

```sql
CREATE TABLE 表名 (
    列1 INT,
    列2 VARCHAR(50),
    UNIQUE (列1, 列2)
);
```

**自动创建索引：**

- `UNIQUE`约束通常会在底层自动创建唯一索引。因此，对带有`UNIQUE`约束的列进行检索或排序的性能较好。

**违反唯一性的操作：**

- 如果插入或更新操作违反了`UNIQUE`约束，MySQL将抛出唯一性冲突的错误。在进行这些操作前应该确保要插入或更新的值不会导致唯一性冲突。

```sql
INSERT INTO 表名 (列1, 列2) VALUES (1, '值1'); -- 正确
INSERT INTO 表名 (列1, 列2) VALUES (1, '值2'); -- 违反唯一性约束
```

**变更注意事项：**

- 在表已经存在的情况下，要添加`UNIQUE`约束，表中的数据必须保证唯一性。如果表中已经有重复的值，需要先处理这些冲突再添加`UNIQUE`约束。

```sql
ALTER TABLE 表名 ADD UNIQUE (列1);
```

# 插入数据（`INSERT INTO`）

## 示例

想象你有一张表格，表格的每一行代表一位同学的信息，有姓名、年龄和成绩三列。

**打开表格（表）：**

- 在MySQL中，就是打开你要插入数据的表。比如，我们打开了一张叫做`students`的表。

```sql
USE your_database_name; -- 切换到你的数据库
```

**选择要插入的位置（表的列）：**

- 告诉MySQL你要在哪个表格的哪几列插入数据。在我们的例子中，我们要插入姓名、年龄和成绩。

```sql
INSERT INTO students (name, age, score) VALUES
```

**填写信息（插入具体的数据）：**

- 在表格中填写新同学的信息。比如，小明，13岁，成绩90。

```sql
('小明', 13, 90);
```

**整合成完整的插入语句：**

- 将上述两步整合在一起，形成完整的插入语句。

```sql
INSERT INTO students (name, age, score) VALUES ('小明', 13, 90);
```

## 注意事项

**列顺序和值的对应：**

- 插入数据时，要确保列名和对应的值的顺序是一致的。比如，如果你的表有列 `name`、`age`、`score`，那么你插入的值的顺序也应该是 `name`、`age`、`score`。

```sql
INSERT INTO students (name, age, score) VALUES ('小明', 13, 90);
```

**数据类型匹配：**

- 插入的值的数据类型要与表中对应列的数据类型匹配。如果某一列是整数类型，那么插入时对应的值也应该是整数。

```sql
INSERT INTO students (name, age, score) VALUES ('小明', '13', 90); -- 错误示例，'13' 应为整数
```

**字符串使用单引号：**

- 如果插入的值是字符串，要确保用单引号括起来。

```sql
INSERT INTO students (name, age, score) VALUES ('小明', 13, 90);
```

**主键约束：**

- 如果表中有主键，确保插入的数据不会导致主键重复。主键是表中唯一标识每一行记录的列。

```sql
INSERT INTO students (id, name, age, score) VALUES (1, '小明', 13, 90);
```

当然，一般主键都是自增的，我们不需要给主键赋值。

**默认值：**

- 如果表中某一列有默认值，可以选择不插入该列的值，数据库会使用默认值。

```sql
INSERT INTO students (name, age) VALUES ('小明', 13); -- score 列会使用默认值
```

**插入多行数据：**

- `INSERT INTO`语句可以一次插入多行数据，只需在`VALUES`后面添加多组值。

```sql
INSERT INTO students (name, age, score) VALUES
('小明', 13, 90),
('小红', 14, 95),
('小刚', 13, 88);
```

**良好的数据准备：**

- 在执行插入操作之前，确保你的数据准备工作已经完成，例如数据已经清理、格式正确等。

**事务处理：**

- 在插入大量数据时，可以考虑使用事务处理，以确保数据的一致性和完整性。

# 更新（修改）数据（`UPDATE`）

当你想要修改数据库表中已经存在的数据时，你可以使用 MySQL 中的 `UPDATE` 语句。这就好像你在纸上修改错别字一样，只不过是在数据库里进行的修改。

## 示例

想象你有一张表格，里面记录了同学的名字、年龄和成绩。现在你发现小明的成绩写错了，他实际上是 95 分，而不是原来的 90 分。

**找到小明的那一行（定位数据）：**

- 就像在表格里找到小明的那一行一样，在 MySQL 中，我们使用 `WHERE` 子句来定位要修改的行。

```sql
UPDATE students SET score = 95 WHERE name = '小明';
```

**修改小明的成绩：**

- 然后告诉数据库你要把小明的成绩改成 95 分。

```sql
UPDATE students SET score = 95 WHERE name = '小明';
```

**提交修改（保存修改）：**

- 最后，告诉数据库你已经完成了修改，要保存这个修改。

> 一般的语法格式为：
>
> ```sql
> UPDATE table_name
> SET column1 = value1, column2 = value2, ...
> WHERE condition;
> ```
>
> - **table_name**：要修改的表名称。
> - **column1, column2, ...**：要修改的字段名称，可以为多个字段。
> - **value1, value2, ...**：要修改的值，可以为多个值。
> - **condition**：修改条件，用于指定哪些数据要修改。

## 注意事项

**使用 `WHERE` 子句：**

- `UPDATE` 语句会更新表中所有符合条件的记录。因此，务必使用 `WHERE` 子句来明确指定哪些行需要被更新。如果不使用 `WHERE`，可能会导致意外地修改整个表的数据。

```sql
UPDATE students SET score = 95 WHERE name = '小明';
```

**确保条件唯一性：**

- 如果可能的话，确保 `WHERE` 子句的条件足够唯一，以免误操作。确保只有目标行满足条件。

```sql
UPDATE students SET score = 95 WHERE student_id = 123; -- 使用唯一的 student_id
```

**备份数据：**

- 在执行大规模更新或者重要数据的更新操作之前，最好备份数据。这可以在意外发生时提供数据的还原点。

**避免过度更新：**

- 谨慎使用 `UPDATE` 语句，特别是在生产环境中。过度更新可能导致性能问题和数据一致性问题。确保只更新必要的数据。

**事务处理：**

- 对于涉及多个表或需要多个步骤的复杂更新，使用事务处理确保数据的一致性。在更新操作完成之后，使用 `COMMIT` 提交事务。

```sql
START TRANSACTION;
-- 执行一系列更新操作
COMMIT;
```

这一步一般不需要我们手动去操作，一般的数据库软件都能做到，点一下，或者回车之类的。

**考虑性能：**

- 在更新大量数据时，要考虑更新操作的性能。如果可能的话，避免在大表上执行没有索引支持的更新操作，以提高查询效率。

**数据类型匹配：**

- 确保更新的值与目标列的数据类型匹配，以避免数据转换错误。

```sql
UPDATE students SET age = '15' WHERE name = '小明'; -- 错误示例，'15' 应为整数
```

**更新部分字段：**

- 可以选择仅更新需要修改的列，而不必修改整行的所有数据。

```sql
UPDATE students SET score = 95 WHERE name = '小明'; -- 只更新成绩，而不修改其他信息
```

**测试更新语句：**

- 在执行更新语句之前，先使用 `SELECT` 语句检查 `WHERE` 子句，确保它选中了你希望更新的行。

```sql
SELECT * FROM students WHERE name = '小明';
```

# 删除（行）数据（`DELETE`）

当你想要从数据库中删除一些信息时，就可以使用 MySQL 中的 `DELETE` 语句。这就好像你在擦掉一张纸上的某些文字一样。

## 示例

想象你有一张同学名单表格，里面记录了同学们的名字、年龄和成绩。现在你发现表里有一个错误的记录，记录了一个不存在的同学，名字叫做"小花"，你要把这个错误的记录删除。

**找到要删除的那一行（定位数据）：**

- 就像在表格里找到那个错误记录的行一样，在 MySQL 中，我们使用 `WHERE` 子句来定位要删除的行。

```sql
SELECT * FROM students WHERE name = '小花';
```

**确认删除操作（删除数据）：**

- 然后告诉数据库你要删除这个找到的记录。

```sql
DELETE FROM students WHERE name = '小花';
```

**提交删除（保存删除操作）：**

- 最后，告诉数据库你已经完成了删除操作，要保存这个删除。

## 注意事项

**使用 `WHERE` 子句：**

- `DELETE` 语句会删除表中所有符合条件的记录。因此，务必使用 `WHERE` 子句来明确指定哪些行需要被删除。如果不使用 `WHERE`，可能会导致意外地删除整个表的数据。

```sql
DELETE FROM students WHERE name = '小花';
```

**确保条件唯一性：**

- 确保 `WHERE` 子句的条件足够唯一，以免误删除其他不需要删除的数据。确保只有目标行满足条件。

```sql
DELETE FROM students WHERE student_id = 123; -- 使用唯一的 student_id
```

**备份数据：**

- 在执行大规模删除或者删除重要数据之前，最好备份数据。这可以在意外发生时提供数据的还原点。

**避免没有 `WHERE` 的删除：**

- 不要轻易执行没有 `WHERE` 子句的 `DELETE` 语句，因为这会删除整个表中的所有数据。

```sql
DELETE FROM students; -- 慎用，会删除整个表中的数据
```

**事务处理：**

- 对于涉及多个表或需要多个步骤的复杂删除操作，使用事务处理确保数据的一致性。在删除操作完成之后，使用 `COMMIT` 提交事务。

```sql
START TRANSACTION;
-- 执行一系列删除操作
COMMIT;
```

**考虑性能：**

- 在删除大量数据时，要考虑删除操作的性能。如果可能的话，避免在大表上执行没有索引支持的删除操作，以提高查询效率。

**谨慎使用 `DELETE`：**

- 谨慎使用 `DELETE`，尤其是在生产环境中。过度删除可能导致数据丢失和性能问题。

**测试删除语句：**

- 在执行删除语句之前，先使用 `SELECT` 语句检查 `WHERE` 子句，确保它选中了你希望删除的行。

```sql
SELECT * FROM students WHERE name = '小花';
```

## 关于删除的补充

在 MySQL 中，有几种不同的删除操作，包括 `DELETE`、`TRUNCATE` 和 `DROP`，它们有不同的作用和用途。以下是它们的主要区别：

### **DELETE**

- **作用：** 用于删除表中的记录。
- **影响范围：** 可以通过使用 `WHERE` 子句来指定删除的记录。可以删除满足条件的一行或多行数据。
- **保留结构：** 表结构不受影响，只删除数据。
- **事务支持：** `DELETE` 操作是事务安全的，可以与事务一起使用。

```sql
DELETE FROM table_name WHERE condition;
```

### **TRUNCATE**

- **作用：** 用于快速删除表中的所有数据。
- **影响范围：** 删除整个表中的所有数据，而不考虑任何条件。没有 `WHERE` 子句。
- **保留结构：** 保留表的结构，只删除数据。
- **重置计数器：** 在某些数据库中，`TRUNCATE` 操作还可以重置自增计数器（如果有的话）。
- **事务支持：** `TRUNCATE` 操作通常比 `DELETE` 操作更快，但不支持回滚。

```sql
TRUNCATE TABLE table_name;
```

### **DROP**

- **作用：** 用于删除整个表，包括表的结构、数据以及相关的索引、约束等。
- **影响范围：** 删除整个表，无法恢复。
- **保留结构：** 表结构也被删除，不再存在。
- **事务支持：** `DROP` 操作是 DDL（数据定义语言）命令，不能回滚。执行后表不可恢复地被删除。

```sql
DROP TABLE table_name;
```

>这里说的事务安全是指什么呢？
>
>在数据库管理系统中，事务（Transaction）是一组数据库操作，被看作是一个不可分割的工作单元。事务具有以下四个特性，通常被称为 ACID 特性：
>
>1. **原子性（Atomicity）：** 事务是一个原子操作，要么全部执行成功，要么全部执行失败。如果在事务执行过程中发生错误，系统会回滚（Rollback）事务，将数据库恢复到事务开始之前的状态，保持数据的一致性。
>2. **一致性（Consistency）：** 事务执行前后，数据库从一个一致的状态转变到另一个一致的状态。事务执行过程中，数据库约束不会被破坏，确保数据的完整性。
>3. **隔离性（Isolation）：** 事务的执行是相互隔离的，一个事务的执行不应影响其他事务的执行。事务之间应该是相互独立的，就好像它们是在系统中独立运行一样。
>4. **持久性（Durability）：** 一旦事务被提交，其结果应该是永久性的，即使系统崩溃，也能够通过数据库的恢复机制将数据还原到事务提交后的状态。
>
>说白了，如果是事务安全的，删除操作如果中途出现了什么问题导致了删除失败，则会回滚到删除之前的状态。
>
>比方说执行了一条删除语句，需要删除表中五条数据，但是在第三条的时候不知道咋了无法删除，但是已经删了两条数据了，如果是事务安全的，则会回滚到之前的状态，等于什么都没删。如果不是事务安全的，那么结果就是永久的删掉了这两条数据。
>
>也就是说，要么全部成功，要么全部失败。

剩下的几个外键，CHECK之类的后面再说，今天复习的蛮多了，结束！





