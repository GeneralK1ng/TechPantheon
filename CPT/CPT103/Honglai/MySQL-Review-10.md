继续来到数据库的规范化，也就是一种优化数据库结构的一种范式。

# 数据库的规范化

## 良好数据库设计规范

**最小化属性数量：**

- 数据库应该包含最少数量的属性，足以支持企业的数据需求。这有助于保持数据库的简洁性，提高查询效率，并降低维护成本。只有必要的属性应该包含在数据库中，避免不必要的冗余。

**具有紧密逻辑关系的属性在同一关系中：**

- 相关的属性应该组织在同一关系（表）中，以反映它们之间的紧密逻辑关系。这有助于简化查询和维护操作，并提高数据库的一致性。例如，如果有关联的用户信息和订单信息，它们应该存储在同一关系中，而不是分散在不同的表中。

**最小冗余：**

- 数据库设计应该避免冗余，即相同的数据不应该在数据库中存储多次。冗余数据可能导致更新异常、插入异常和删除异常，从而影响数据库的一致性。每个属性只应该在数据库中表示一次，除非它是外键的一部分或完全是外键。外键是关联两个表的字段，允许在表之间建立关系。

**外键的例外：**

- 外键是一种属性，它们与另一个表中的主键或唯一键形成关联。尽管规范化目标是减少冗余，但外键是一个例外，因为它们用于建立表之间的关系。在这种情况下，外键的一部分或整体可能在多个表中出现，但这是为了保持关系完整性。在外键的情况下，允许属性在不同表中多次出现，以便确保相关表之间的关联性。

## 什么是数据库的规范化

数据库规范化是一种数据库设计的方法，旨在通过组织数据库表的结构，减少数据冗余、提高数据一致性，并防止数据异常。这个过程通过将表拆分成更小、更紧凑的结构，以确保每个表都包含相关的数据，并且每个数据项都只在数据库中存储一次。这有助于减小数据库的复杂性，提高查询性能，并减少数据更新时的潜在问题。

## ER建模与规范化

实体关系建模（ER建模）和规范化是数据库设计中两个关键的步骤，它们各自关注不同的方面，但又相互关联，通常在数据库设计的不同阶段应用。

### ER建模（Entity-Relationship Modeling）：

**定义：** ER建模是一种用于描述数据库中数据实体、它们之间的关系和属性的图形化方法。它使用实体、关系和属性等概念，通过图形表示来描述数据模型，以便更好地理解和沟通数据库的结构。

**特点：**

1. **概念性：** ER模型提供了一个概念性的视图，使人们能够从高层次上理解数据库中的实体以及它们之间的关系。
2. **易于理解：** 通过使用图形符号，ER模型使数据库设计更加可视化和易于理解。
3. **关注业务需求：** ER模型着重于捕捉业务需求和实体之间的关系，而不涉及具体的表结构。

### 规范化（Normalization）：

**定义：** 规范化是一种通过设计数据库表结构，以最小化冗余、降低数据异常的方法。这通常涉及将表拆分成更小的、更精确的结构，以确保每个表都符合特定的范式。

**特点：**

1. **结构化：** 规范化关注数据库表的结构，以确保数据存储是结构化的、一致的，且没有不必要的冗余。
2. **范式：** 通过遵循范式的规则，规范化确保表的设计符合特定的标准，如第一范式、第二范式和第三范式等。
3. **提高性能：** 通过减小表的大小，规范化有助于提高查询性能，并减少数据更新时的潜在问题。

### 关联：

1. **设计阶段：** ER建模通常是在数据库设计的早期阶段进行的，用于捕捉业务需求和关系。规范化通常发生在ER建模之后，用于优化数据库表的结构。
2. **相互关联：** ER模型的实体和关系可以为规范化提供一个起点。规范化过程中可能需要调整表结构，以更好地反映ER模型中定义的实体和它们之间的关系。
3. **业务和性能：** ER建模更侧重于业务需求和关系，而规范化更关注数据库的结构和性能。

## 数据冗余的问题

数据冗余是指在数据库中存储相同信息的多个副本或冗余副本。虽然在某些情况下可能会选择故意引入一些冗余以提高查询性能，但通常情况下，过多的数据冗余可能导致一系列问题，包括：

1. **更新异常：** 当存在数据冗余时，如果更新操作只更新了其中一个副本而忘记更新其他副本，可能导致数据的不一致性。这被称为更新异常，其中数据的更新不同步，导致数据库中存在不一致的信息。
2. **插入异常：** 插入异常发生在试图插入新数据时，由于要求插入的数据所依赖的其他信息尚未存在，导致插入操作无法完成。这通常是由于数据分散在多个地方造成的，而不是集中存储。
3. **删除异常：** 删除异常发生在尝试删除某些数据时，由于这些数据同时被其他数据所引用，删除操作可能导致丢失不想删除的相关信息。这使得删除操作变得复杂并且可能引起问题。
4. **数据不一致性：** 数据冗余使得难以保持数据的一致性。如果同一信息的不同副本之间存在不一致，用户可能会看到相互矛盾的数据。
5. **空间浪费：** 存储相同的信息多次会导致空间浪费，尤其是在大型数据库中。这不仅浪费了物理存储空间，还增加了备份和维护的成本。
6. **查询困难：** 数据冗余可能导致查询变得复杂，因为相同的信息分散在不同的地方。这可能需要使用更复杂的查询来获取一致和完整的结果。

# 范式

## 功能依赖

在数据库理论中，**功能依赖（Functional Dependency）** 是指一个属性的值在给定其他属性的值的条件下，能够确定另一个属性的值。简而言之，如果我们知道某个属性（称为**依赖项**）的值，就能够唯一确定另一个属性（称为**依赖源**）的值，那么我们说依赖源函数依赖于依赖项。

在关系数据库中，功能依赖是关系模型中一种重要的概念，通常用于规范化数据库设计。它有助于确保数据库表的结构能够遵循一些基本原则，防止冗余数据、维持数据的一致性，同时减小数据更新异常的风险。

### 功能依赖的表示

在关系数据库中，我们用箭头（→）表示功能依赖。如果属性 X 的值决定了属性 Y 的值，我们写作 X → Y。

例如，假设有一个学生表包含学生的学号（`StudentID`）和姓名（`StudentName`），则可以表示为：

`StudentID`→`StudentNameStudentID`→`StudentName`

这表示在给定学生的学号的情况下，能够唯一确定学生的姓名。

### 完全函数依赖

如果一个属性完全依赖于另一组属性，而不依赖于这组属性的任何子集，那么我们称这是一个完全函数依赖。

例如，如果一个表中有 

`StudentID`→`StudentNameStudentID`→`StudentName` 和 `StudentID`,

 `Course`→`GradeStudentID`, `Course`→`Grade`，那么我们可以说 `Grade` 完全依赖于 `StudentID` 和 `Course`。

### 部分函数依赖

相反，如果一个属性依赖于另一组属性中的一部分，而不是全部，那么我们称这是一个部分函数依赖。

例如，如果 `StudentID`, `Course`→`GradeStudentID`, `Course`→`Grade`，但 `StudentID`→`GradeStudentID`→`Grade` 不成立，那么我们可以说 `Grade` 部分依赖于 `StudentID` 和 `Course`。

### 传递函数依赖

如果一个属性依赖于另一组属性，而这组属性又依赖于另一组属性，那么我们称这是一个传递函数依赖。

例如，如果 `A`→`BA`→`B` 和 `B`→`CB`→`C`，那么我们可以说 `A`→`CA`→`C` 是一个传递函数依赖。

## 例子

假设我们要创建一个学生课程成绩的数据库表，我们可以使用 MySQL 来创建一个包含学生信息、课程信息和成绩的表。以下是一个简单的例子，演示了不同类型的功能依赖。

```sql
-- 创建学生表
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    StudentName VARCHAR(50) NOT NULL,
    BirthDate DATE
);

-- 创建课程表
CREATE TABLE Courses (
    CourseID INT PRIMARY KEY,
    CourseName VARCHAR(50) NOT NULL
);

-- 创建成绩表
CREATE TABLE Grades (
    StudentID INT,
    CourseID INT,
    Grade INT,
    PRIMARY KEY (StudentID, CourseID),
    FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
    FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
);
```

在上面的例子中，我们创建了三个表：`Students`（学生表）、`Courses`（课程表）和`Grades`（成绩表）。

1. **完全函数依赖的例子：**
   - `Grades`表中的`Grade`完全依赖于`StudentID`和`CourseID`。这是因为给定了`StudentID`和`CourseID`的情况下，可以唯一确定相应的`Grade`。
2. **部分函数依赖的例子：**
   - 如果我们假设一个学生只修一个课程，那么`Grades`表中的`Grade`部分依赖于`StudentID`。这是因为给定了`StudentID`，我们就能唯一确定该学生的所有课程成绩。
3. **传递函数依赖的例子：**
   - 如果我们在`Students`表中添加了一个属性`BirthDate`，并假设`CourseID`是与`BirthDate`存在传递依赖关系，那么我们可以说`StudentID`传递函数依赖于`CourseID`。这是因为`StudentID`依赖于`BirthDate`，而`CourseID`又依赖于`StudentID`。请注意，这种情况可能不符合实际业务场景，只是为了演示传递函数依赖的概念。

## 依赖传递

传递依赖是指如果一个属性 A 依赖于属性 B，并且属性 B 依赖于属性 C，则我们可以说属性 A 传递依赖于属性 C。这是一种由依赖关系链条构成的概念，其中属性之间的依赖不是直接的，而是通过其他属性传递的。

### 例子

考虑一个关系模型，其中有三个属性 A、B 和 C，满足以下依赖关系：
$$
A \to B \\\\
B \to C
$$
在这种情况下，我们可以得出传递依赖：
$$
A \to C
$$
这是因为 A 通过 B 间接地依赖于 C。

### 传递依赖的性质：

1. **传递依赖是由直接依赖关系构成的：** 传递依赖并不是一种新的独立关系，而是由直接依赖关系的链条构成的。在上面的例子中，传递依赖 $A \to C$ 是由直接依赖 $A \to B$ 和 $B \to C$构成的。
2. **依赖链可能是多层的：** 传递依赖的链条可能涉及多个属性。在上述例子中，我们只有两层的传递，但在更复杂的关系模型中，这种链条可能更长。
3. **传递依赖的方向是单向的：** 传递依赖是单向的，即 A 传递依赖于 C，并不意味着 C 传递依赖于 A。

# 三大范式

1. **第一范式 (1NF)：** 保证每个表中的每一列都是原子的，不可再分。这意味着每个单元格中的数据不再包含嵌套结构或多个值。
2. **第二范式 (2NF)：** 在满足第一范式的基础上，确保表中的非主键列完全依赖于全部主键而不是部分主键。这有助于消除数据部分依赖性。
3. **第三范式 (3NF)：** 在满足第二范式的基础上，确保表中的非主键列之间没有传递依赖关系。这有助于消除数据传递依赖性。

## 第一范式

**第一范式（First Normal Form，1NF）**是数据库规范化的第一个步骤，它确保数据库表中的数据是原子性的，即每一列都包含不可再分的原子数据。以下是第一范式的一些关键特点和要点：

### 特点

**原子性：**

- 第一范式要求每个表中的每一列都包含不可再分的原子数据。这意味着每一列中不能包含集合、数组、记录或其他类似的结构，而应该是单一的、不可再分的数据类型。

**唯一性：**

- 表中的每一行都应该是唯一的，没有重复的行。这是数据库表的基本特性，但在第一范式中，强调了确保每一行都是唯一的。

**有序性无关：**

- 第一范式与数据的顺序无关，即数据的存储顺序不影响数据的可访问性或完整性。在表中，行的顺序不重要，重要的是每一行都包含正确的、原子的数据。

### 例子

考虑一个包含学生课程成绩的表，不符合第一范式的情况：

| StudentID | Courses                     | Grades |
| --------- | --------------------------- | ------ |
| 1         | Math, Physics               | A, B   |
| 2         | Chemistry, Computer Science | A, A   |

上述表中的"Courses"和"Grades"列包含多个数据项，不是原子的。为了符合第一范式，我们可以将这个表分解为两个表：

-- 学生表
| StudentID |
| --------- |
| 1         |
| 2         |

-- 课程成绩表
| StudentID | Course        | Grade |
| --------- | ------------- | ----- |
| 1         | Math          | A     |
| 1         | Physics       | B     |
| 2         | Chemistry     | A     |
| 2         | Comp. Science | A     |

这样，每个表都包含原子数据，并且不再存在多个值的情况。

第一范式是数据库规范化的基础，确保数据的原子性，使得数据库结构更加清晰、可维护，同时避免了与非规范化数据结构相关的问题。在实际设计中，应该始终考虑将表调整为满足第一范式的形式。

## 第二范式

**第二范式（Second Normal Form，2NF）**是数据库规范化的第二步，它建立在第一范式的基础上，解决了包含部分依赖的问题。第二范式的关键思想是确保表中的所有非主键列完全依赖于主键，而不是依赖于主键的部分属性。以下是第二范式的一些关键特点和要点：

### 特点

**完全函数依赖：**

- 第二范式要求表中的非主键列完全函数依赖于主键。换句话说，如果一个表的主键是由多个属性组成的，那么所有其他非主键列都应该完全依赖于这个组合主键，而不是只依赖于主键的一部分。

**消除部分依赖：**

- 通过确保所有非主键列都完全依赖于主键，第二范式帮助消除了表中的部分依赖关系。部分依赖是指表中的某些列仅依赖于主键的一部分。

### 例子

考虑一个包含学生课程成绩的表，不符合第二范式的情况：

| StudentID | Course        | Professor   | Grade |
| --------- | ------------- | ----------- | ----- |
| 1         | Math          | Dr. Smith   | A     |
| 1         | Physics       | Dr. Johnson | B     |
| 2         | Chemistry     | Dr. Davis   | A     |
| 2         | Comp. Science | Dr. Smith   | A     |

在上述表中，主键是 (StudentID, Course)，其中"Professor"列只依赖于主键的一部分（"Course"），这违反了第二范式。为了符合第二范式，我们可以将表分解为这几个表：

-- 学生表
| StudentID |
| --------- |
| 1         |
| 2         |

-- 课程表
| Course        | Professor   |
| ------------- | ----------- |
| Math          | Dr. Smith   |
| Physics       | Dr. Johnson |
| Chemistry     | Dr. Davis   |
| Comp. Science | Dr. Smith   |

-- 课程成绩表
| StudentID | Course        | Grade |
| --------- | ------------- | ----- |
| 1         | Math          | A     |
| 1         | Physics       | B     |
| 2         | Chemistry     | A     |
| 2         | Comp. Science | A     |

现在，“Professor”只依赖于“Course”，而不再依赖于主键，因此符合第二范式的要求。

第二范式通过确保表中的非主键列完全依赖于主键，帮助规范化数据库表结构，提高数据的一致性和完整性。在实际数据库设计中，应该仔细分析表的依赖关系，以确保它们符合第二范式的要求。

## 第三范式

**第三范式（Third Normal Form，3NF）**是数据库规范化的第三步，它建立在第二范式的基础上，解决了表中的传递依赖问题。第三范式的核心思想是确保表中的所有非主键列都不传递依赖于主键，即不存在非主键列之间的传递依赖关系。以下是第三范式的一些关键特点和要点：

### 特点

**消除传递依赖：**

- 第三范式要求表中的非主键列不应该传递依赖于主键。如果一个非主键列依赖于主键，而另一列依赖于这个非主键列，那么就存在传递依赖。

**避免冗余数据：**

- 通过消除传递依赖，第三范式有助于避免表中的冗余数据。这有助于数据库结构的清晰性、一致性和减小存储空间的需求。

### 例子

考虑一个包含学生课程成绩的表，不符合第三范式的情况：

| StudentID | Course        | Professor   | ProfessorOffice | Grade |
| --------- | ------------- | ----------- | --------------- | ----- |
| 1         | Math          | Dr. Smith   | Room 101        | A     |
| 1         | Physics       | Dr. Johnson | Room 105        | B     |
| 2         | Chemistry     | Dr. Davis   | Room 103        | A     |
| 2         | Comp. Science | Dr. Smith   | Room 101        | A     |

在上述表中，"ProfessorOffice"列依赖于"Professor"，而"Professor"又依赖于主键。这导致了传递依赖，不符合第三范式的要求。为了符合第三范式，我们可以将表分解为这几个表：

-- 学生表
| StudentID |
| --------- |
| 1         |
| 2         |

-- 课程表
| Course        | Professor   |
| ------------- | ----------- |
| Math          | Dr. Smith   |
| Physics       | Dr. Johnson |
| Chemistry     | Dr. Davis   |
| Comp. Science | Dr. Smith   |

-- 教授表
| Professor   | ProfessorOffice |
| ----------- | --------------- |
| Dr. Smith   | Room 101        |
| Dr. Johnson | Room 105        |
| Dr. Davis   | Room 103        |

-- 课程成绩表
| StudentID | Course        | Grade |
| --------- | ------------- | ----- |
| 1         | Math          | A     |
| 1         | Physics       | B     |
| 2         | Chemistry     | A     |
| 2         | Comp. Science | A     |

这样，每个表都不存在传递依赖，符合第三范式的要求。

第三范式通过消除表中的传递依赖，帮助规范化数据库表结构，确保非主键列之间没有不必要的依赖关系。在实际数据库设计中，应该仔细分析表的依赖关系，以确保它们符合第三范式的要求，提高数据库的结构清晰性和一致性。

## 实操

比方说如果我们要设计一个图书管理系统，首先我们应该怎么办？

肯定是先进行ER模型的建立。

### ER模型设计

在ER模型中，我们可能有以下几个实体和它们之间的关系：

- 实体：图书（Book）、作者（Author）、图书馆成员（Library Member）
- 关系：图书与作者之间是“写作”关系，图书馆成员与图书之间是“借阅”关系。

我们还可以画出这几个关系的ER图

![](https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/libManagementER.png)

### 数据库设计

根据ER模型，我们可以设计初始的数据库表结构：

-- 图书表
| BookID | Title           | ISBN        | AuthorID |
| ------ | --------------- | ----------- | -------- |
| 1      | "Introduction…" | "123456789" | 1        |
| 2      | "Database Des…" | "987654321" | 2        |

-- 作者表
| AuthorID | AuthorName   |
| -------- | ------------ |
| 1        | "John Smith" |
| 2        | "Jane Doe"   |

-- 图书馆成员表
| MemberID | MemberName      | MemberEmail       |
| -------- | --------------- | ----------------- |
| 101      | "Alice Johnson" | "alice@email.com" |

### 第一范式（1NF）

确保每列都包含原子数据，消除重复的列。

好像这个表已经满足第一范式了，所以跳过。

### 第二范式（2NF）

确保非主键列完全依赖于主键。

-- 图书表
| BookID | Title           | ISBN        |
| ------ | --------------- | ----------- |
| 1      | "Introduction…" | "123456789" |
| 2      | "Database Des…" | "987654321" |

-- 作者表
| AuthorID | AuthorName   |
| -------- | ------------ |
| 1        | "John Smith" |
| 2        | "Jane Doe"   |

-- 图书作者关系表

| BookID | AuthorID |
| ------ | -------- |
| 1      | 1        |
| 2      | 2        |

-- 图书馆成员表

| MemberID | MemberName      | MemberEmail       |
| -------- | --------------- | ----------------- |
| 101      | "Alice Johnson" | "alice@email.com" |

### 第三范式（3NF）

仔细一看，这样好像也已经复合第三范式了。。。

## 总结

那就总结一下：

### 第一范式（1NF）：

**目标：** 确保数据库表字段的原子性。

**例子：** 如果有一个包含用户信息的字段，如 "广东省 10086"，根据第一范式，应该拆分成 "省份：广东省" 和 "电话号码：10086" 两个字段，以确保每个字段都是原子的，不可再分。

### 第二范式（2NF）：

**目标：** 除了满足第一范式，表必须有一个主键；非主键列必须完全依赖于主键。

**例子：** 考虑一个选课关系表，包含学号、学生姓名、年龄、课程名称、成绩和学分。如果学分完全依赖于课程名称，而姓名和年龄完全依赖于学号，那么这不符合第二范式。解决方法是拆分成学生表、课程表和选课关系表，确保每个表有自己的主键，消除部分依赖。

### 第三范式（3NF）：

**目标：** 除了满足第二范式，非主键列必须直接依赖于主键，不能存在传递依赖。

**例子：** 考虑一个学生关系表，包含学号、学生姓名、年龄、学院ID、学院地点和学院电话。如果学院地点和学院电话直接依赖于学院ID，而学院ID又依赖于学号，存在传递依赖，不符合第三范式。解决方法是拆分成学生表和学院表，确保非主键列直接依赖于主键。

### 2NF 和 3NF 的区别：

- **2NF：** 考虑非主键列是否完全依赖于主键。
- **3NF：** 考虑非主键列是否直接依赖于主键，避免传递依赖。



